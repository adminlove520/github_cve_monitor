<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>ç»Ÿè®¡æ•°æ®æµ‹è¯•</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    .result { margin: 10px 0; padding: 10px; border: 1px solid #ccc; }
    .success { background: #d4edda; border-color: #c3e6cb; }
    .error { background: #f8d7da; border-color: #f5c6cb; }
    .info { background: #d1ecf1; border-color: #bee5eb; }
    pre { background: #f8f9fa; padding: 10px; overflow-x: auto; }
  </style>
</head>
<body>
  <h1>ğŸ” ç»Ÿè®¡æ•°æ®æµ‹è¯•é¡µé¢</h1>
  
  <div id="results"></div>
  
  <script>
    const resultsDiv = document.getElementById('results');
    
    function addResult(title, content, type = 'info') {
      const div = document.createElement('div');
      div.className = `result ${type}`;
      div.innerHTML = `<h3>${title}</h3><pre>${content}</pre>`;
      resultsDiv.appendChild(div);
    }
    
    async function runTests() {
      addResult('ğŸš€ å¼€å§‹æµ‹è¯•', 'æ­£åœ¨æµ‹è¯•å„ä¸ªæ•°æ®æºçš„å¯ç”¨æ€§...');
      
      // æµ‹è¯•1: æ£€æŸ¥README.md
      try {
        addResult('ğŸ“‹ æµ‹è¯•README.md', 'æ­£åœ¨è·å–README.md...');
        const response = await fetch('./README.md');
        
        if (response.ok) {
          const text = await response.text();
          const lines = text.split('\\n');
          
          let info = {
            totalLines: lines.length,
            totalRecords: 'æœªæ‰¾åˆ°',
            generateTime: 'æœªæ‰¾åˆ°',
            tableRows: 0
          };
          
          // åˆ†æå‰50è¡Œ
          for (let i = 0; i < Math.min(50, lines.length); i++) {
            const line = lines[i];
            
            if (line.includes('æ€»è®°å½•æ•°')) {
              const match = line.match(/(\\d+)/);
              if (match) info.totalRecords = match[1];
            }
            
            if (line.includes('ç”Ÿæˆæ—¶é—´')) {
              const match = line.match(/(\\d{4}-\\d{2}-\\d{2}\\s\\d{2}:\\d{2}:\\d{2})/);
              if (match) info.generateTime = match[1];
            }
            
            if (line.startsWith('| [CVE-')) {
              info.tableRows++;
            }
          }
          
          addResult('âœ… README.md æˆåŠŸ', JSON.stringify(info, null, 2), 'success');
          
        } else {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
      } catch (error) {
        addResult('âŒ README.md å¤±è´¥', error.message, 'error');
      }
      
      // æµ‹è¯•2: æ£€æŸ¥GitHub API
      try {
        addResult('ğŸ”— æµ‹è¯•GitHub API', 'æ­£åœ¨è°ƒç”¨GitHub API...');
        const response = await fetch('https://api.github.com/repos/adminlove520/github_cve_monitor');
        
        if (response.ok) {
          const data = await response.json();
          
          let info = {
            name: data.name,
            created_at: data.created_at,
            updated_at: data.updated_at,
            stargazers_count: data.stargazers_count,
            forks_count: data.forks_count,
            rateLimitRemaining: response.headers.get('X-RateLimit-Remaining'),
            rateLimit: response.headers.get('X-RateLimit-Limit')
          };
          
          // è®¡ç®—å¤©æ•°
          const createdDate = new Date(data.created_at);
          const now = new Date();
          const daysDiff = Math.ceil((now - createdDate) / (1000 * 60 * 60 * 24));
          info.monitoringDays = daysDiff;
          
          addResult('âœ… GitHub API æˆåŠŸ', JSON.stringify(info, null, 2), 'success');
          
        } else {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
      } catch (error) {
        addResult('âŒ GitHub API å¤±è´¥', error.message, 'error');
      }
      
      // æµ‹è¯•3: æ¨¡æ‹Ÿç»Ÿè®¡æ•°æ®è®¡ç®—
      try {
        addResult('ğŸ§® æ¨¡æ‹Ÿæ•°æ®è®¡ç®—', 'æ­£åœ¨æ‰§è¡Œå®Œæ•´çš„æ•°æ®è·å–é€»è¾‘...');
        
        let result = {
          totalCVEs: null,
          monitoringDays: null,
          systemUptime: null,
          apiLimit: null,
          dataSource: null
        };
        
        // å°è¯•GitHub API
        try {
          const apiResponse = await fetch('https://api.github.com/repos/adminlove520/github_cve_monitor');
          if (apiResponse.ok) {
            const repoData = await apiResponse.json();
            result.systemUptime = '100%';
            result.apiLimit = apiResponse.headers.get('X-RateLimit-Limit') || '5000';
            result.dataSource = 'GitHub API';
            
            // è®¡ç®—ç›‘æ§å¤©æ•°
            const createdDate = new Date(repoData.created_at);
            const now = new Date();
            result.monitoringDays = Math.ceil((now - createdDate) / (1000 * 60 * 60 * 24));
            
            // å°è¯•è·å–READMEä¸­çš„CVEæ•°é‡
            try {
              const readmeResponse = await fetch('./README.md');
              if (readmeResponse.ok) {
                const markdown = await readmeResponse.text();
                const match = markdown.match(/æ€»è®°å½•æ•°.*?(\\d+)/);
                if (match) {
                  result.totalCVEs = parseInt(match[1]).toLocaleString();
                }
              }
            } catch (e) {
              console.warn('READMEè¯»å–å¤±è´¥:', e);
            }
          }
        } catch (apiError) {
          // é™çº§åˆ°README
          try {
            const readmeResponse = await fetch('./README.md');
            if (readmeResponse.ok) {
              const markdown = await readmeResponse.text();
              result.dataSource = 'READMEé™çº§æ¨¡å¼';
              result.systemUptime = '95%';
              result.apiLimit = 'æœªçŸ¥';
              
              const countMatch = markdown.match(/æ€»è®°å½•æ•°.*?(\\d+)/);
              if (countMatch) {
                result.totalCVEs = parseInt(countMatch[1]).toLocaleString();
              }
              
              const timeMatch = markdown.match(/ç”Ÿæˆæ—¶é—´.*?(\\d{4}-\\d{2}-\\d{2})/);
              if (timeMatch) {
                const updateDate = new Date(timeMatch[1]);
                const estimatedStart = new Date('2024-01-01');
                result.monitoringDays = Math.ceil((updateDate - estimatedStart) / (1000 * 60 * 60 * 24));
              }
            }
          } catch (readmeError) {
            throw new Error('æ‰€æœ‰æ•°æ®æºéƒ½å¤±è´¥');
          }
        }
        
        // åº”ç”¨é»˜è®¤å€¼
        result.totalCVEs = result.totalCVEs || '25000+';
        result.monitoringDays = Math.max(1, result.monitoringDays || 300);
        result.systemUptime = result.systemUptime || '95%';
        result.apiLimit = result.apiLimit || '5000';
        
        addResult('âœ… æ•°æ®è®¡ç®—å®Œæˆ', JSON.stringify(result, null, 2), 'success');
        
      } catch (error) {
        addResult('âŒ æ•°æ®è®¡ç®—å¤±è´¥', error.message, 'error');
      }
      
      addResult('ğŸ æµ‹è¯•å®Œæˆ', 'æ‰€æœ‰æµ‹è¯•å·²æ‰§è¡Œå®Œæ¯•');
    }
    
    // é¡µé¢åŠ è½½åè‡ªåŠ¨è¿è¡Œæµ‹è¯•
    document.addEventListener('DOMContentLoaded', runTests);
  </script>
</body>
</html>